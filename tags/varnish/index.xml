<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Drupal WxT â€“ varnish</title><link>https://drupalwxt.github.io/tags/varnish/</link><description>Recent content in varnish on Drupal WxT</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://drupalwxt.github.io/tags/varnish/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Varnish</title><link>https://drupalwxt.github.io/docs/development/performance/varnish/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://drupalwxt.github.io/docs/development/performance/varnish/</guid><description>
&lt;p>To properly configure Varnish with Drupal you should ensure the following configuration is your &lt;code>default.vcl&lt;/code> file.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Note&lt;/strong>: Some customizations might be necessary depending on your individual requirements.&lt;/p>
&lt;/blockquote>
&lt;pre tabindex="0">&lt;code class="language-vcl" data-lang="vcl">vcl 4.0;
import std;
import directors;
backend nginx {
.host = &amp;#34;hostname-nginx&amp;#34;;
.host_header = &amp;#34;hostname-nginx&amp;#34;;
.port = &amp;#34;80&amp;#34;;
}
sub vcl_init {
new backends = directors.round_robin();
backends.add_backend(nginx);
}
sub vcl_recv {
set req.http.X-Forwarded-Host = req.http.Host;
if (!req.http.X-Forwarded-Proto) {
set req.http.X-Forwarded-Proto = &amp;#34;http&amp;#34;;
}
# Answer healthcheck
if (req.url == &amp;#34;/_healthcheck&amp;#34; || req.url == &amp;#34;/healthcheck.txt&amp;#34;) {
return (synth(700, &amp;#34;HEALTHCHECK&amp;#34;));
}
set req.backend_hint = backends.backend();
# Answer healthcheck
if (req.url == &amp;#34;/_healthcheck&amp;#34; || req.url == &amp;#34;/healthcheck.txt&amp;#34;) {
return (synth(700, &amp;#34;HEALTHCHECK&amp;#34;));
}
set req.backend_hint = backends.backend();
# Always cache certain file types
# Remove cookies that Drupal doesn&amp;#39;t care about
if (req.url ~ &amp;#34;(?i)\.(asc|dat|tgz|png|gif|jpeg|jpg|ico|swf|css|js)(\?.*)?$&amp;#34;) {
unset req.http.Cookie;
} else if (req.http.Cookie) {
set req.http.Cookie = &amp;#34;;&amp;#34; + req.http.Cookie;
set req.http.Cookie = regsuball(req.http.Cookie, &amp;#34;; +&amp;#34;, &amp;#34;;&amp;#34;);
set req.http.Cookie = regsuball(req.http.Cookie, &amp;#34;;(SESS[a-z0-9]+|SSESS[a-z0-9]+|NO_CACHE)=&amp;#34;, &amp;#34;; \1=&amp;#34;);
set req.http.Cookie = regsuball(req.http.Cookie, &amp;#34;;[^ ][^;]*&amp;#34;, &amp;#34;&amp;#34;);
set req.http.Cookie = regsuball(req.http.Cookie, &amp;#34;^[; ]+|[; ]+$&amp;#34;, &amp;#34;&amp;#34;);
if (req.http.Cookie == &amp;#34;&amp;#34;) {
unset req.http.Cookie;
} else {
return (pass);
}
}
# If POST, PUT or DELETE, then don&amp;#39;t cache
if (req.method == &amp;#34;POST&amp;#34; || req.method == &amp;#34;PUT&amp;#34; || req.method == &amp;#34;DELETE&amp;#34;) {
return (pass);
}
# Happens before we check if we have this in cache already.
#
# Typically you clean up the request here, removing cookies you don&amp;#39;t need,
# rewriting the request, etc.
return (hash);
#return (pass);
}
sub vcl_backend_fetch {
# NEW
set bereq.http.Host = &amp;#34;hostname-nginx&amp;#34;;
# Don&amp;#39;t add 127.0.0.1 to X-Forwarded-For
set bereq.http.X-Forwarded-For = regsub(bereq.http.X-Forwarded-For, &amp;#34;(, )?127\.0\.0\.1$&amp;#34;, &amp;#34;&amp;#34;);
}
sub vcl_backend_response {
if (beresp.http.Location) {
set beresp.http.Location = regsub(
beresp.http.Location,
&amp;#34;^https?://[^/]+/&amp;#34;,
bereq.http.X-Forwarded-Proto + &amp;#34;://&amp;#34; + bereq.http.X-Forwarded-Host + &amp;#34;/&amp;#34;
);
}
# Only cache select response codes
if (beresp.status == 200 || beresp.status == 203 || beresp.status == 204 || beresp.status == 206 || beresp.status == 300 || beresp.status == 301 || beresp.status == 404 || beresp.status == 405 || beresp.status == 410 || beresp.status == 414 || beresp.status == 501) {
# Cache for 5 minutes
set beresp.ttl = 5m;
set beresp.grace = 12h;
set beresp.keep = 24h;
} else {
set beresp.ttl = 0s;
}
}
sub vcl_deliver {
# Remove identifying information
unset resp.http.Server;
unset resp.http.X-Powered-By;
unset resp.http.X-Varnish;
unset resp.http.Via;
# Comment these for easier Drupal cache tag debugging in development.
unset resp.http.Cache-Tags;
unset resp.http.X-Drupal-Cache-Contexts;
# Add Content-Security-Policy
# set resp.http.Content-Security-Policy = &amp;#34;default-src &amp;#39;self&amp;#39; *.example.ca *.example.ca; style-src &amp;#39;self&amp;#39; &amp;#39;unsafe-inline&amp;#39; *.example.ca https://fonts.googleapis.com; script-src &amp;#39;self&amp;#39; &amp;#39;unsafe-inline&amp;#39; &amp;#39;unsafe-eval&amp;#39; *.example.ca *.adobedtm.com use.fontawesome.com blob:; connect-src &amp;#39;self&amp;#39; *.example.ca *.omtrdc.net *.demdex.net *.everesttech.net; img-src &amp;#39;self&amp;#39; *.example.ca *.omtrdc.net *.demdex.net *.everesttech.net data:; font-src &amp;#39;self&amp;#39; *.example.ca https://fonts.gstatic.com&amp;#34;;
# Add CORS Headers
# if (req.http.Origin ~ &amp;#34;(?i)\.example\.ca$&amp;#34;) {
# if (req.url ~ &amp;#34;\.(ttd|woff|woff2)(\?.*)?$&amp;#34;) {
# set resp.http.Access-Control-Allow-Origin = &amp;#34;*&amp;#34;;
# set resp.http.Access-Control-Allow-Methods = &amp;#34;GET&amp;#34;;
# }
# }
# Add X-Frame-Options
if (req.url ~ &amp;#34;^/livechat&amp;#34; || req.url ~ &amp;#34;^/(en/|fr/)?entity-browser/&amp;#34;) {
set resp.http.X-Frame-Options = &amp;#34;SAMEORIGIN&amp;#34;;
} else {
set resp.http.X-Frame-Options = &amp;#34;DENY&amp;#34;;
}
set resp.http.X-Content-Type-Options = &amp;#34;nosniff&amp;#34;;
set resp.http.X-XSS-Protection = &amp;#34;1; mode=block&amp;#34;;
# Happens when we have all the pieces we need, and are about to send the
# response to the client.
#
# You can do accounting or modifying the final object here.
if (obj.hits &amp;gt; 0) {
set resp.http.X-Cache = &amp;#34;HIT&amp;#34;;
} else {
set resp.http.X-Cache = &amp;#34;MISS&amp;#34;;
}
# Handle errors
if ( (resp.status &amp;gt;= 500 &amp;amp;&amp;amp; resp.status &amp;lt;= 599)
|| resp.status == 400
|| resp.status == 401
|| resp.status == 403
|| resp.status == 404) {
return (synth(resp.status));
}
}
sub vcl_synth {
# Remove identifying information
unset resp.http.Server;
unset resp.http.X-Powered-By;
unset resp.http.X-Varnish;
unset resp.http.Via;
# Add Content-Security-Policy
# set resp.http.Content-Security-Policy = &amp;#34;default-src &amp;#39;self&amp;#39; *.example.ca; style-src &amp;#39;self&amp;#39; &amp;#39;unsafe-inline&amp;#39; *.example.ca; script-src &amp;#39;self&amp;#39; &amp;#39;unsafe-inline&amp;#39; &amp;#39;unsafe-eval&amp;#39; *.example.ca *.adobedtm.com use.fontawesome.com blob:; connect-src &amp;#39;self&amp;#39; *.example.ca *.omtrdc.net *.demdex.net *.everesttech.net; img-src &amp;#39;self&amp;#39; *.example.ca data:;&amp;#34;;
# set resp.http.X-Content-Type-Options = &amp;#34;nosniff&amp;#34;;
# set resp.http.X-Frame-Options = &amp;#34;DENY&amp;#34;;
# set resp.http.X-XSS-Protection = &amp;#34;1; mode=block&amp;#34;;
# if (resp.status &amp;gt;= 500 &amp;amp;&amp;amp; resp.status &amp;lt;= 599) {
# set resp.http.Content-Type = &amp;#34;text/html; charset=utf-8&amp;#34;;
# synthetic(std.fileread(&amp;#34;/data/configuration/varnish/errors/503.html&amp;#34;));
# return (deliver);
# } elseif (resp.status == 400) { # 400 - Bad Request
# set resp.http.Content-Type = &amp;#34;text/html; charset=utf-8&amp;#34;;
# synthetic(std.fileread(&amp;#34;/data/configuration/varnish/errors/400.html&amp;#34;));
# return (deliver);
# } elseif (resp.status == 401) { # 401 - Unauthorized
# set resp.http.Content-Type = &amp;#34;text/html; charset=utf-8&amp;#34;;
# synthetic(std.fileread(&amp;#34;/data/configuration/varnish/errors/401.html&amp;#34;));
# return (deliver);
# } elseif (resp.status == 403) { # 403 - Forbidden
# set resp.http.Content-Type = &amp;#34;text/html; charset=utf-8&amp;#34;;
# synthetic(std.fileread(&amp;#34;/data/configuration/varnish/errors/403.html&amp;#34;));
# return (deliver);
# } elseif (resp.status == 404) { # 404 - Not Found
# set resp.http.Content-Type = &amp;#34;text/html; charset=utf-8&amp;#34;;
# synthetic(std.fileread(&amp;#34;/data/configuration/varnish/errors/404.html&amp;#34;));
# return (deliver);
# } else
if (resp.status == 700) { # Respond to healthcheck
set resp.status = 200;
set resp.http.Content-Type = &amp;#34;text/plain&amp;#34;;
synthetic ( {&amp;#34;OK&amp;#34;} );
return (deliver);
}
}
##
# ERROR HANDLING
##
# sub vcl_backend_error {
# set beresp.http.Content-Type = &amp;#34;text/html; charset=utf-8&amp;#34;;
# synthetic(std.fileread(&amp;#34;/data/configuration/varnish/errors/503.html&amp;#34;));
# return (deliver);
# }
&lt;/code>&lt;/pre></description></item></channel></rss>